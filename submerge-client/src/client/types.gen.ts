// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://coretime-polkadot.crystal.submerge.io/api/v1' | 'https://{chain}.crystal.submerge.io/api/v1' | (string & {});
};

/**
 * 32-byte Substrate account id as lowercase hex, **always** `0x`-prefixed and lowercase in responses.
 */
export type AccountIdHex = string;

/**
 * 20-byte address as lowercase hex, **always** `0x`-prefixed and lowercase in responses.
 */
export type Address20Hex = string;

/**
 * 32-byte address as lowercase hex, **always** `0x`-prefixed and lowercase in responses.
 */
export type Address32Hex = string;

/**
 * A block in the blockchain.
 */
export type Block = {
    /**
     * Authoring validator address.
     */
    author?: MultiAddress;
    /**
     * Number of events in the block.
     */
    eventCount: number;
    /**
     * Number of extrinsics in the block.
     */
    extrinsicCount: number;
    /**
     * Merkle root of included extrinsics.
     */
    extrinsicRoot: Hash256Hex;
    /**
     * Block hash (Blake2 256-bit).
     */
    hash: Hash256Hex;
    /**
     * Block height.
     */
    number: bigint;
    /**
     * Parent block hash.
     */
    parentHash: Hash256Hex;
    /**
     * Runtime spec version.
     */
    specVersion: number;
    /**
     * Root hash of the state trie after executing this block.
     */
    stateRoot: Hash256Hex;
    /**
     * Block status.
     */
    status: BlockStatus;
    /**
     * Block timestamp. Milliseconds.
     */
    timestamp?: bigint;
    /**
     * Block weight in JSON format. Schema depends on runtime metadata.
     */
    weight?: {
        [key: string]: unknown;
    };
};

/**
 * Block status.
 * - `finalized`: Blocks that have been finalized on chain.
 * - `proposed`: Blocks that have been authored but not yet finalized.
 * - `pruned`: Blocks that have been removed or are no longer accessible.
 */
export enum BlockStatus {
    PROPOSED = 'proposed',
    PRUNED = 'pruned',
    FINALIZED = 'finalized'
}

/**
 * A runtime call.
 */
export type Call = {
    /**
     * Call arguments in JSON format. Schema depends on the call's schema definition in the runtime metadata.
     */
    args?: {
        [key: string]: unknown;
    };
    /**
     * Hash of the call's block.
     */
    blockHash: Hash256Hex;
    /**
     * Number of the call's block.
     */
    blockNumber: bigint;
    /**
     * Status of the call's block.
     */
    blockStatus: BlockStatus;
    /**
     * Timestamp of the call's block. Milliseconds.
     */
    blockTimestamp?: bigint;
    /**
     * Index of the call, represented as an unsigned integer array.
     */
    callIndex: Array<number>;
    /**
     * Rust-style path of the call represented with parameter names or indices.
     */
    callPath: string;
    /**
     * Hash of the call's extrinsic.
     */
    extrinsicHash: Hash256Hex;
    /**
     * Index of the call's extrinsic.
     */
    extrinsicIndex: number;
    /**
     * Whether the call's extrinsic was successful.
     * Note: The extrinsic can be successful where the call has failed (see the `Utility.ForceBatch`` call).
     */
    extrinsicIsSuccessful: boolean;
    /**
     * Artificial call hash.
     */
    hash: Hash256Hex;
    /**
     * Index of the call in its pallet.
     */
    palletCallIndex: number;
    /**
     * Name of the call.
     */
    palletCallName: string;
    /**
     * Pallet index of the call.
     */
    palletIndex: number;
    /**
     * Pallet name of the call.
     */
    palletName: string;
    /**
     * Hash of the parent call if this call is a nested call (batch, multisig, etc.).
     */
    parentCallHash?: Hash256Hex;
    /**
     * Runtime spec version of the call's block.
     */
    specVersion: number;
};

/**
 * Call arguments wrapper.
 */
export type CallArgs = {
    [key: string]: unknown;
};

/**
 * Generic error type.
 */
export type Error = {
    /**
     * Error message.
     */
    message: string;
};

/**
 * A runtime event.
 */
export type Event = {
    /**
     * Call arguments in JSON format. Schema depends on the call's schema definition in the runtime metadata.
     */
    args?: {
        [key: string]: unknown;
    };
    /**
     * Hash of the event's block.
     */
    blockHash: Hash256Hex;
    /**
     * Number of the event's block.
     */
    blockNumber: bigint;
    /**
     * Status of the event's block.
     */
    blockStatus: BlockStatus;
    /**
     * Timestamp of the event's block. Milliseconds.
     */
    blockTimestamp?: bigint;
    /**
     * Hash of the event's extrinsic, if it was output from an extrinsic.
     */
    extrinsicHash?: Hash256Hex;
    /**
     * Index of the event's extrinsic, if it was output from an extrinsic.
     */
    extrinsicIndex?: number;
    /**
     * Artificial event hash.
     */
    hash: Hash256Hex;
    /**
     * Index of the event in block.
     */
    index: number;
    /**
     * Index of the event in its pallet.
     */
    palletEventIndex: number;
    /**
     * Name of the event.
     */
    palletEventName: string;
    /**
     * Pallet index of the event.
     */
    palletIndex: number;
    /**
     * Pallet name of the event.
     */
    palletName: string;
    /**
     * Event phase.
     */
    phase: string;
    /**
     * Runtime spec version of the event's block.
     */
    specVersion: number;
    /**
     * Index of the event's trace, if traces are enabled.
     */
    traceIndex?: number;
};

/**
 * Event arguments wrapper.
 */
export type EventArgs = {
    [key: string]: unknown;
};

/**
 * An extrinsic in a block. Signed or unsigned.
 */
export type Extrinsic = {
    /**
     * Hash of the extrinsic's block.
     */
    blockHash: Hash256Hex;
    /**
     * Number of the extrinsic's block.
     */
    blockNumber: bigint;
    /**
     * Status of the extrinsic's block.
     */
    blockStatus: BlockStatus;
    /**
     * Timestamp of the extrinsic's block. Milliseconds.
     */
    blockTimestamp?: bigint;
    /**
     * Extrinsic extras in JSON format - checkNonce, checkGenesis, chargeTransactionPayment, etc.
     */
    extra?: {
        [key: string]: unknown;
    };
    /**
     * Extrinsic hash.
     */
    hash: Hash256Hex;
    /**
     * Extrinsic index.
     */
    index: number;
    /**
     * Whether the extrinsic was successful.
     */
    isSuccessful: boolean;
    /**
     * Extrinsic signature address.
     */
    signature?: MultiSignature;
    /**
     * Extrinsic signer address.
     */
    signer?: MultiAddress;
    /**
     * Runtime spec version of the extrinsic's block.
     */
    specVersion: number;
    /**
     * Trace index for the extrinsic.
     */
    traceIndex?: number;
    /**
     * Extrinsic version in metadata.
     */
    version: number;
};

/**
 * A storage item initialized at genesis.
 */
export type GenesisRecord = {
    /**
     * Storage item key parameter(s) for the genesis record.
     */
    keyParams?: HexString;
    /**
     * Storage item key prefix for the genesis record.
     */
    keyPrefix: HexString;
    /**
     * If the record is a known UTF-8 key, the string representation of the key.
     */
    knownKey?: string;
    /**
     * If the record is a storage item, the storage item's pallet index in the metadata.
     */
    palletIndex?: number;
    /**
     * If the record is a storage item, the storage item's pallet name in the metadata.
     */
    palletName?: string;
    /**
     * If the record is a storage item, the storage item's index in the pallet metadata.
     */
    palletStorageItemIndex?: number;
    /**
     * If the record is a storage item, the storage item's name.
     */
    palletStorageItemName?: string;
    /**
     * Value of the genesis record.
     */
    value: HexString;
};

/**
 * 32-byte Blake2b-256, **always** `0x`-prefixed and lowercase in responses.
 * Inputs elsewhere may accept mixed case or missing `0x`; the API normalizes outputs.
 */
export type Hash256Hex = string;

/**
 * Arbitrary hex-encoded bytes, `0x`-prefixed.
 */
export type HexString = string;

/**
 * Arbitrary hex-encoded bytes, mixed case, optional `0x`-prefix.
 */
export type HexStringParam = string;

/**
 * Parsed metadata specification complete with its pallets.
 */
export type Metadata = {
    /**
     * Metadata version.
     */
    metadataVersion: number;
    /**
     * Metadata pallets.
     */
    pallets: Array<MetadataPallet>;
    /**
     * Metadata runtime spec version.
     */
    specVersion: number;
};

/**
 * A call defined in a metadata pallet.
 */
export type MetadataCall = {
    /**
     * Call documentation. One item per line in the array.
     */
    docs: MetadataItemDocumentation;
    /**
     * Call's index inside the metadata pallet.
     */
    index: number;
    /**
     * Call name. Camel case.
     */
    name: string;
};

/**
 * A constant defined in a metadata pallet.
 */
export type MetadataConstant = {
    /**
     * Constant documentation. One item per line in the array.
     */
    docs: MetadataItemDocumentation;
    /**
     * Constant's index inside the metadata pallet.
     */
    index: number;
    /**
     * Constant name. Camel case.
     */
    name: string;
    /**
     * Id of the constant's type.
     */
    typeId?: number;
    /**
     * Name of the constant's type.
     */
    typeName: string;
    /**
     * Metadata constant value in JSON format. Schema depends on the definition within the runtime metadata.
     */
    value?: {
        [key: string]: unknown;
    };
    /**
     * Value of the constant. SCALE-encoded hexadecimal string.
     */
    valueHex: HexString;
};

/**
 * An error defined in a metadata pallet.
 */
export type MetadataError = {
    /**
     * Error documentation. One item per line in the array.
     */
    docs: MetadataItemDocumentation;
    /**
     * Error's index inside the metadata pallet.
     */
    index: number;
    /**
     * Error name. Camel case.
     */
    name: string;
};

/**
 * An event defined in a metadata pallet.
 */
export type MetadataEvent = {
    /**
     * Event documentation. One item per line in the array.
     */
    docs: MetadataItemDocumentation;
    /**
     * Event's index inside the metadata pallet.
     */
    index: number;
    /**
     * Event name. Camel case.
     */
    name: string;
};

/**
 * Metadata item documentation. One item per line in the array.
 */
export type MetadataItemDocumentation = Array<string>;

/**
 * Original Substrate runtime metadata in JSON representation.
 */
export type MetadataJson = unknown;

/**
 * A pallet defined in metadata, with its calls, constants, errors, events, and storage items.
 */
export type MetadataPallet = {
    /**
     * Pallet's calls.
     */
    calls: Array<MetadataCall>;
    /**
     * Pallet's constants.
     */
    constants: Array<MetadataConstant>;
    /**
     * Pallet's errors.
     */
    errors: Array<MetadataError>;
    /**
     * Pallet's events.
     */
    events: Array<MetadataEvent>;
    /**
     * Pallet's index inside the metadata.
     */
    index: number;
    /**
     * Pallet's name.
     */
    name: string;
    /**
     * Pallet's storage items.
     */
    storageItems: Array<MetadataStorageItem>;
};

/**
 * The summary of a pallet defined in metadata, with only its index and name.
 */
export type MetadataPalletSummary = {
    /**
     * Pallet's index inside the metadata.
     */
    index: number;
    /**
     * Pallet's name.
     */
    name: string;
};

/**
 * A storage item defined in a metadata pallet.
 */
export type MetadataStorageItem = {
    /**
     * Storage item documentation. One item per line in the array.
     */
    docs: MetadataItemDocumentation;
    /**
     * Storage item's index inside the metadata pallet.
     */
    index: number;
    /**
     * Storage item Substrate storage key prefix.
     */
    keyPrefix: HexString;
    /**
     * Storage item name. Camel case.
     */
    name: string;
};

/**
 * Basic fields to represent a runtime version metadata.
 */
export type MetadataSummary = {
    /**
     * Metadata version.
     */
    metadataVersion: number;
    /**
     * Metadata runtime spec version.
     */
    specVersion: number;
};

/**
 * Discriminated union for the Substrate multi-address type.
 * The `type` tag selects the variant; `value` carries the payload.
 */
export type MultiAddress = ({
    type: 'accountId';
} & MultiAddressAccountId) | ({
    type: 'MultiAddressAccountIndex';
} & MultiAddressAccountIndex) | ({
    type: 'raw';
} & MultiAddressRaw) | ({
    type: 'address20';
} & MultiAddress20) | ({
    type: 'address32';
} & MultiAddress32);

/**
 * 20-byte address.
 */
export type MultiAddress20 = {
    /**
     * Must be `address20`.
     */
    type: MultiAddress20Type;
    value: Address20Hex;
};

/**
 * Multi-address 20-byte address type.
 */
export enum MultiAddress20Type {
    ADDRESS20 = 'address20'
}

/**
 * 32-byte address.
 */
export type MultiAddress32 = {
    /**
     * Must be `address32`.
     */
    type: MultiAddress32Type;
    value: Address32Hex;
};

/**
 * Multi-address 32-byte address type.
 */
export enum MultiAddress32Type {
    ADDRESS32 = 'address32'
}

/**
 * 32-byte account id.
 */
export type MultiAddressAccountId = {
    /**
     * Must be `accountId`.
     */
    type: MultiAddressAccountIdType;
    /**
     * Account id as 32-byte hex.
     */
    value: AccountIdHex;
};

/**
 * Multi-address 32-byte account id type.
 */
export enum MultiAddressAccountIdType {
    ACCOUNT_ID = 'accountId'
}

/**
 * Account index.
 */
export type MultiAddressAccountIndex = {
    /**
     * Must be `index`.
     */
    type: MultiAddressIndexType;
    /**
     * Account index value.
     */
    value: number;
};

/**
 * Multi-address account index type.
 */
export enum MultiAddressIndexType {
    INDEX = 'index'
}

/**
 * Raw account address.
 */
export type MultiAddressRaw = {
    /**
     * Must be `raw`.
     */
    type: MultiAddressRawType;
    value: HexString;
};

/**
 * Multi-address raw account address type.
 */
export enum MultiAddressRawType {
    RAW = 'raw'
}

/**
 * Discriminated union for the Substrate multi-signature type.
 * The `type` tag selects the variant; `value` carries the payload.
 */
export type MultiSignature = ({
    type: 'ecdsa';
} & MultiSignatureEcdsa) | ({
    type: 'eth';
} & MultiSignatureEth) | ({
    type: 'ed25519';
} & MultiSignatureEd25519) | ({
    type: 'sr25519';
} & MultiSignatureSr25519);

/**
 * ECDSA signature.
 */
export type MultiSignatureEcdsa = {
    /**
     * Must be `ecdsa`.
     */
    type: MultiSignatureEcdsaType;
    /**
     * ECDSA signature hex.
     */
    value: SignatureHexString;
};

/**
 * Multi-signature ECDSA type.
 */
export enum MultiSignatureEcdsaType {
    ECDSA = 'ecdsa'
}

/**
 * Ed25519 signature.
 */
export type MultiSignatureEd25519 = {
    /**
     * Must be `ed25519`.
     */
    type: MultiSignatureEd25519Type;
    /**
     * Ed25519 signature hex.
     */
    value: SignatureHexString;
};

/**
 * Multi-signature Ed25519 type.
 */
export enum MultiSignatureEd25519Type {
    ED25519 = 'ed25519'
}

/**
 * Eth signature.
 */
export type MultiSignatureEth = {
    /**
     * Must be `eth`.
     */
    type: MultiSignatureEthType;
    /**
     * Eth signature hex.
     */
    value: SignatureHexString;
};

/**
 * Multi-signature Eth type (ECDSA over secp256k1, applied to a Keccak-256 hash).
 */
export enum MultiSignatureEthType {
    ETH = 'eth'
}

/**
 * Sr25519 signature.
 */
export type MultiSignatureSr25519 = {
    /**
     * Must be `sr25519`.
     */
    type: MultiSignatureSr25519Type;
    /**
     * Sr25519 signature hex.
     */
    value: SignatureHexString;
};

/**
 * Multi-signature Sr25519 type.
 */
export enum MultiSignatureSr25519Type {
    SR25519 = 'sr25519'
}

/**
 * Pagination data for paged responses.
 */
export type PaginationData = {
    /**
     * Current page number. 1-indexed.
     */
    page: number;
    /**
     * Number of items per page.
     */
    pageSize: number;
    /**
     * Total number of items across all pages.
     */
    total: bigint;
};

/**
 * and ECDSA (65 bytes → 130 hex chars). **Always** `0x`-prefixed and lowercase in responses.
 * Inputs elsewhere may accept mixed case or missing `0x`; the API normalizes outputs.
 */
export type SignatureHexString = string;

/**
 * A trace record in a block.
 */
export type Trace = {
    /**
     * Hash of the trace's block.
     */
    blockHash: Hash256Hex;
    /**
     * Number of the trace's block.
     */
    blockNumber: bigint;
    /**
     * ExtId value for the trace record.
     */
    extId: HexString;
    /**
     * Artificial hash of the trace (`sha256(block_hash || index)`).
     */
    hash: Hash256Hex;
    /**
     * Index of the trace within the block.
     */
    index: number;
    /**
     * Substrate storage parameters appended to the end of the storage key,
     * if the storage item has parameters.
     */
    keyParams?: HexString;
    /**
     * Substrate storage key prefix of the trace record.
     */
    keyPrefix: HexString;
    /**
     * If the trace record is for a known UTF-8 key, the string representation of the key.
     */
    knownKey?: string;
    /**
     * If the trace record is a storage item, the storage item's pallet index in the metadata.
     */
    palletIndex?: number;
    /**
     * If the trace record is a storage item, the storage item's pallet name in the metadata.
     */
    palletName?: string;
    /**
     * If the trace record is a storage item, the storage item's index in the pallet metadata.
     */
    palletStorageItemIndex?: number;
    /**
     * If the trace record is a storage item, the storage item's name.
     */
    palletStorageItemName?: string;
    parentId?: string | null;
    /**
     * Runtime spec version of the call's block.
     */
    specVersion: number;
    /**
     * Trace storage method.
     */
    storageMethod: TraceStorageMethod;
};

/**
 * Block trace storage method.
 */
export enum TraceStorageMethod {
    PUT = 'Put',
    CHILD_PUT = 'ChildPut',
    CHILD_KILL = 'ChildKill',
    CLEAR_PREFIX = 'ClearPrefix',
    CHILD_CLEAR_PREFIX = 'ChildClearPrefix',
    APPEND = 'Append',
    GENESIS = 'Genesis'
}

export type GetBlocksData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Block list page number to retrieve. 1-indexed.
         */
        page?: number;
        /**
         * Number of blocks per page to be returned.
         */
        page_size?: number;
        /**
         * Filter results by block status. If not specified, all blocks are returned.
         */
        status?: BlockStatus;
        /**
         * Filter blocks by minimum block number.
         */
        min_block_number?: bigint;
        /**
         * Filter blocks by maximum block number.
         */
        max_block_number?: bigint;
        /**
         * Filter blocks by minimum block timestamp. In milliseconds.
         */
        min_block_timestamp?: bigint;
        /**
         * Filter blocks by maximum block timestamp. In milliseconds.
         */
        max_block_timestamp?: bigint;
        /**
         * Filter blocks by minimum runtime spec version.
         */
        min_spec_version?: number;
        /**
         * Filter blocks by maximum runtime spec version.
         */
        max_spec_version?: number;
        /**
         * Filter results by block author. Either of the following:
         * - Author's Substrate SS58 address string (e.g. `5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY`).
         * - Author's Substrate account id encoded as a hexadecimal string (e.g. `0x008d8404893c7b4b80f397605cc96e61fec3c89676c8c2794a2a7d281d678b1a`).
         * - Author's address encoded as a hexadecimal string with optional `0x` prefix (e.g. `0x008d8404893c7b4b80f397605cc96e61fec3c89676c8c2794a2a7d281d678b1a`).
         */
        author?: string;
    };
    url: '/blocks';
};

export type GetBlocksErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetBlocksError = GetBlocksErrors[keyof GetBlocksErrors];

export type GetBlocksResponses = {
    /**
     * Paginated list of matching blocks.
     */
    200: {
        data: Array<Block>;
        pagination: PaginationData;
    };
};

export type GetBlocksResponse = GetBlocksResponses[keyof GetBlocksResponses];

export type GetBlocksByReferenceData = {
    body?: never;
    path: {
        /**
         * Block reference. Either a block number (integer ≥ 0), or a block hash in hex (with or without `0x` prefix, case-insensitive).
         */
        block_ref: string;
    };
    query?: never;
    url: '/blocks/{block_ref}';
};

export type GetBlocksByReferenceErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetBlocksByReferenceError = GetBlocksByReferenceErrors[keyof GetBlocksByReferenceErrors];

export type GetBlocksByReferenceResponses = {
    /**
     * List of matching blocks.
     */
    200: Array<Block>;
};

export type GetBlocksByReferenceResponse = GetBlocksByReferenceResponses[keyof GetBlocksByReferenceResponses];

export type GetCallsByBlockReferenceData = {
    body?: never;
    path: {
        /**
         * Block reference for the calls. Either a block number (integer ≥ 0), or a block hash in hex (with or without `0x` prefix, case-insensitive).
         */
        block_ref: string;
    };
    query?: {
        /**
         * Block call list page number to retrieve. 1-indexed.
         */
        page?: number;
        /**
         * Number of block calls per page to be returned.
         */
        page_size?: number;
        /**
         * Filter blocks calls by pallet name. Case insensitive.
         */
        pallet_name?: string;
        /**
         * Filter blocks calls by call name. Case insensitive.
         */
        pallet_call_name?: string;
        /**
         * Whether to include call arguments in the block calls in the response.
         * Default is `false`. Setting this to `true` increases the response size considerably.
         * Prefer to use the `GET /call/{call_hash}/args` endpoint per call instead.
         */
        include_args?: boolean;
    };
    url: '/blocks/{block_ref}/calls';
};

export type GetCallsByBlockReferenceErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetCallsByBlockReferenceError = GetCallsByBlockReferenceErrors[keyof GetCallsByBlockReferenceErrors];

export type GetCallsByBlockReferenceResponses = {
    /**
     * Paginated list of matching calls.
     */
    200: {
        data: Array<Call>;
        pagination: PaginationData;
    };
};

export type GetCallsByBlockReferenceResponse = GetCallsByBlockReferenceResponses[keyof GetCallsByBlockReferenceResponses];

export type GetEventsByBlockReferenceData = {
    body?: never;
    path: {
        /**
         * Block reference for the events. Either a block number (integer ≥ 0), or a block hash in hex (with or without `0x` prefix, case-insensitive).
         */
        block_ref: string;
    };
    query?: {
        /**
         * Block event list page number to retrieve. 1-indexed.
         */
        page?: number;
        /**
         * Number of block events per page to be returned.
         */
        page_size?: number;
        /**
         * Filter events calls by pallet name. Case insensitive.
         */
        pallet_name?: string;
        /**
         * Filter blocks events by event name. Case insensitive.
         */
        pallet_event_name?: string;
        /**
         * Whether to include event arguments in the block events in the response.
         * Default is `false`. Setting this to `true` increases response size considerably.
         * Prefer to use the `GET /event/{event_hash}/args` endpoint per call instead.
         */
        include_args?: boolean;
    };
    url: '/blocks/{block_ref}/events';
};

export type GetEventsByBlockReferenceErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetEventsByBlockReferenceError = GetEventsByBlockReferenceErrors[keyof GetEventsByBlockReferenceErrors];

export type GetEventsByBlockReferenceResponses = {
    /**
     * Paginated list of matching events.
     */
    200: {
        data: Array<Event>;
        pagination: PaginationData;
    };
};

export type GetEventsByBlockReferenceResponse = GetEventsByBlockReferenceResponses[keyof GetEventsByBlockReferenceResponses];

export type GetEventsByBlockReferenceAndIndexData = {
    body?: never;
    path: {
        /**
         * Block reference for the event(s). Either a block number (integer ≥ 0), or a block hash in hex (with or without `0x` prefix, case-insensitive).
         */
        block_ref: string;
        /**
         * 0-based index for the event(s) in the block(s).
         */
        event_index: number;
    };
    query?: {
        /**
         * Whether to include event arguments in the event(s) in the response.
         * Default is `false`. Setting this to `true` increases the response size considerably.
         * Prefer to use the `GET /event/{event_hash}/args` endpoint per call instead.
         */
        include_args?: boolean;
    };
    url: '/blocks/{block_ref}/events/{event_index}';
};

export type GetEventsByBlockReferenceAndIndexErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetEventsByBlockReferenceAndIndexError = GetEventsByBlockReferenceAndIndexErrors[keyof GetEventsByBlockReferenceAndIndexErrors];

export type GetEventsByBlockReferenceAndIndexResponses = {
    /**
     * List of matching events.
     */
    200: Array<Event>;
};

export type GetEventsByBlockReferenceAndIndexResponse = GetEventsByBlockReferenceAndIndexResponses[keyof GetEventsByBlockReferenceAndIndexResponses];

export type GetExtrinsicsByBlockReferenceData = {
    body?: never;
    path: {
        /**
         * Block reference for the extrinsics. Either a block number (integer ≥ 0), or a block hash in hex (with or without `0x` prefix, case-insensitive).
         */
        block_ref: string;
    };
    query?: {
        /**
         * Block call list page number to retrieve. 1-indexed.
         */
        page?: number;
        /**
         * Number of block calls per page to be returned.
         */
        page_size?: number;
        /**
         * Whether to include only signed/unsigned extrinsics within the block.
         */
        is_signed?: boolean;
        /**
         * Filter block extrinsics by signer. Either of the following:
         * - Signer's Substrate SS58 address string (e.g. `5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY`).
         * - Signer's Substrate account id encoded as a hexadecimal string (e.g. `0x008d8404893c7b4b80f397605cc96e61fec3c89676c8c2794a2a7d281d678b1a`).
         * - Signer's address encoded as a hexadecimal string with optional `0x` prefix (e.g. `0x008d8404893c7b4b80f397605cc96e61fec3c89676c8c2794a2a7d281d678b1a`).
         */
        signer?: string | null;
    };
    url: '/blocks/{block_ref}/extrinsics';
};

export type GetExtrinsicsByBlockReferenceErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetExtrinsicsByBlockReferenceError = GetExtrinsicsByBlockReferenceErrors[keyof GetExtrinsicsByBlockReferenceErrors];

export type GetExtrinsicsByBlockReferenceResponses = {
    /**
     * Paginated list of matching extrinsics.
     */
    200: {
        data: Array<Extrinsic>;
        pagination: PaginationData;
    };
};

export type GetExtrinsicsByBlockReferenceResponse = GetExtrinsicsByBlockReferenceResponses[keyof GetExtrinsicsByBlockReferenceResponses];

export type GetExtrinsicsByBlockReferenceAndIndexData = {
    body?: never;
    path: {
        /**
         * Block reference for the extrinsic. Either a block number (integer ≥ 0), or a block hash in hex (with or without `0x` prefix, case-insensitive).
         */
        block_ref: string;
        /**
         * 0-based index for the extrinsic in the block.
         */
        extrinsic_index: number;
    };
    query?: never;
    url: '/blocks/{block_ref}/extrinsics/{extrinsic_index}';
};

export type GetExtrinsicsByBlockReferenceAndIndexErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetExtrinsicsByBlockReferenceAndIndexError = GetExtrinsicsByBlockReferenceAndIndexErrors[keyof GetExtrinsicsByBlockReferenceAndIndexErrors];

export type GetExtrinsicsByBlockReferenceAndIndexResponses = {
    /**
     * List of matching extrinsics.
     */
    200: Array<Extrinsic>;
};

export type GetExtrinsicsByBlockReferenceAndIndexResponse = GetExtrinsicsByBlockReferenceAndIndexResponses[keyof GetExtrinsicsByBlockReferenceAndIndexResponses];

export type GetCallsByBlockReferenceAndExtrinsicIndexData = {
    body?: never;
    path: {
        /**
         * Block reference for the extrinsic. Either a block number (integer ≥ 0), or a block hash in hex (with or without `0x` prefix, case-insensitive).
         */
        block_ref: string;
        /**
         * 0-based index for the extrinsic in the block.
         */
        extrinsic_index: number;
    };
    query?: {
        /**
         * Block call list page number to retrieve. 1-indexed.
         */
        page?: number;
        /**
         * Number of block calls per page to be returned.
         */
        page_size?: number;
        /**
         * Filter blocks calls by pallet name. Case insensitive.
         */
        pallet_name?: string;
        /**
         * Filter blocks calls by call name. Case insensitive.
         */
        pallet_call_name?: string;
        /**
         * Whether to include call arguments in the block calls in the response.
         * Default is `false`. Setting this to `true` increases the response size considerably.
         * Prefer to use the `GET /call/{call_hash}/args` endpoint per call instead.
         */
        include_args?: boolean;
    };
    url: '/blocks/{block_ref}/extrinsics/{extrinsic_index}/calls';
};

export type GetCallsByBlockReferenceAndExtrinsicIndexErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetCallsByBlockReferenceAndExtrinsicIndexError = GetCallsByBlockReferenceAndExtrinsicIndexErrors[keyof GetCallsByBlockReferenceAndExtrinsicIndexErrors];

export type GetCallsByBlockReferenceAndExtrinsicIndexResponses = {
    /**
     * Paginated list of matching calls.
     */
    200: {
        data: Array<Call>;
        pagination: PaginationData;
    };
};

export type GetCallsByBlockReferenceAndExtrinsicIndexResponse = GetCallsByBlockReferenceAndExtrinsicIndexResponses[keyof GetCallsByBlockReferenceAndExtrinsicIndexResponses];

export type GetEventsByBlockReferenceAndExtrinsicIndexData = {
    body?: never;
    path: {
        /**
         * Block reference for the extrinsic. Either a block number (integer ≥ 0), or a block hash in hex (with or without `0x` prefix, case-insensitive).
         */
        block_ref: string;
        /**
         * 0-based index for the extrinsic in the block.
         */
        extrinsic_index: number;
    };
    query?: {
        /**
         * Block event list page number to retrieve. 1-indexed.
         */
        page?: number;
        /**
         * Number of block events per page to be returned.
         */
        page_size?: number;
        /**
         * Filter events calls by pallet name. Case insensitive.
         */
        pallet_name?: string;
        /**
         * Filter blocks events by event name. Case insensitive.
         */
        pallet_event_name?: string;
        /**
         * Whether to include event arguments in the block events in the response.
         * Default is `false`. Setting this to `true` increases response size considerably.
         * Prefer to use the `GET /event/{event_hash}/args` endpoint per call instead.
         */
        include_args?: boolean;
    };
    url: '/blocks/{block_ref}/extrinsics/{extrinsic_index}/events';
};

export type GetEventsByBlockReferenceAndExtrinsicIndexErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetEventsByBlockReferenceAndExtrinsicIndexError = GetEventsByBlockReferenceAndExtrinsicIndexErrors[keyof GetEventsByBlockReferenceAndExtrinsicIndexErrors];

export type GetEventsByBlockReferenceAndExtrinsicIndexResponses = {
    /**
     * Paginated list of matching events.
     */
    200: {
        data: Array<Event>;
        pagination: PaginationData;
    };
};

export type GetEventsByBlockReferenceAndExtrinsicIndexResponse = GetEventsByBlockReferenceAndExtrinsicIndexResponses[keyof GetEventsByBlockReferenceAndExtrinsicIndexResponses];

export type GetTracesByBlockReferenceData = {
    body?: never;
    path: {
        /**
         * Block reference for the traces. Either a block number (integer ≥ 0), or a block hash in hex (with or without `0x` prefix, case-insensitive).
         */
        block_ref: string;
    };
    query?: {
        /**
         * Block traces list page number to retrieve. 1-indexed.
         */
        page?: number;
        /**
         * Number of traces traces in block per page to be returned.
         */
        page_size?: number;
    };
    url: '/blocks/{block_ref}/traces';
};

export type GetTracesByBlockReferenceErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetTracesByBlockReferenceError = GetTracesByBlockReferenceErrors[keyof GetTracesByBlockReferenceErrors];

export type GetTracesByBlockReferenceResponses = {
    /**
     * Paginated list of matching traces.
     */
    200: {
        data: Array<Trace>;
        pagination: PaginationData;
    };
};

export type GetTracesByBlockReferenceResponse = GetTracesByBlockReferenceResponses[keyof GetTracesByBlockReferenceResponses];

export type GetCallsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Call list page number to retrieve. 1-indexed.
         */
        page?: number;
        /**
         * Number of calls per page to be returned.
         */
        page_size?: number;
        /**
         * Filter calls by minimum block number.
         */
        min_block_number?: bigint;
        /**
         * Filter calls by maximum block number.
         */
        max_block_number?: bigint;
        /**
         * Filter calls by minimum block timestamp. In milliseconds.
         */
        min_block_timestamp?: bigint;
        /**
         * Filter calls by maximum block timestamp. In milliseconds.
         */
        max_block_timestamp?: bigint;
        /**
         * Filter calls by minimum runtime spec version.
         */
        min_spec_version?: number;
        /**
         * Filter calls by maximum runtime spec version.
         */
        max_spec_version?: number;
        /**
         * Filter calls by pallet name. Case insensitive. Stored in `camelCase`.
         */
        pallet_name?: string;
        /**
         * Filter calls by call name. Case insensitive. Stored in `camelCase`.
         */
        call_name?: string;
        /**
         * Whether to include call arguments in the calls in the response.
         * Default is `false`. Setting this to `true` increases the response size considerably.
         * Prefer to use the `GET /call/{call_hash}/args` endpoint per call instead.
         */
        include_args?: boolean;
    };
    url: '/calls';
};

export type GetCallsErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetCallsError = GetCallsErrors[keyof GetCallsErrors];

export type GetCallsResponses = {
    /**
     * Paginated list of matching calls.
     */
    200: {
        data: Array<Call>;
        pagination: PaginationData;
    };
};

export type GetCallsResponse = GetCallsResponses[keyof GetCallsResponses];

export type GetCallByHashData = {
    body?: never;
    path: {
        /**
         * Call hash in hex (with or without `0x` prefix, case-insensitive).
         */
        call_hash: string;
    };
    query?: {
        /**
         * Whether to include call arguments in the call(s) in the response.
         * Default is `false`. Setting this to `true` increases the response size considerably.
         * Prefer to use the `GET /call/{call_hash}/args` endpoint per call instead.
         */
        include_args?: boolean;
    };
    url: '/calls/{call_hash}';
};

export type GetCallByHashErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetCallByHashError = GetCallByHashErrors[keyof GetCallByHashErrors];

export type GetCallByHashResponses = {
    /**
     * Call with the given hash.
     */
    200: Call;
};

export type GetCallByHashResponse = GetCallByHashResponses[keyof GetCallByHashResponses];

export type GetCallArgsByHashData = {
    body?: never;
    path: {
        /**
         * Call hash in hex (with or without `0x` prefix, case-insensitive).
         */
        call_hash: string;
    };
    query?: never;
    url: '/calls/{call_hash}/args';
};

export type GetCallArgsByHashErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetCallArgsByHashError = GetCallArgsByHashErrors[keyof GetCallArgsByHashErrors];

export type GetCallArgsByHashResponses = {
    /**
     * Arguments for the runtime call with the given hash.
     */
    200: CallArgs;
};

export type GetCallArgsByHashResponse = GetCallArgsByHashResponses[keyof GetCallArgsByHashResponses];

export type GetCallExtrinsicByHashData = {
    body?: never;
    path: {
        /**
         * Hash of the extrinsic call in hex (with or without `0x` prefix, case-insensitive).
         */
        call_hash: string;
    };
    query?: never;
    url: '/calls/{call_hash}/extrinsic';
};

export type GetCallExtrinsicByHashErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetCallExtrinsicByHashError = GetCallExtrinsicByHashErrors[keyof GetCallExtrinsicByHashErrors];

export type GetCallExtrinsicByHashResponses = {
    /**
     * The extrinsic that contains the call.
     */
    200: Extrinsic;
};

export type GetCallExtrinsicByHashResponse = GetCallExtrinsicByHashResponses[keyof GetCallExtrinsicByHashResponses];

export type GetParentCallByHashData = {
    body?: never;
    path: {
        /**
         * Sub call hash in hex (with or without `0x` prefix, case-insensitive).
         */
        call_hash: string;
    };
    query?: {
        /**
         * Whether to include call arguments in the call(s) in the response.
         * Default is `false`. Setting this to `true` increases the response size considerably.
         * Prefer to use the `GET /call/{call_hash}/args` endpoint per call instead.
         */
        include_args?: boolean;
    };
    url: '/calls/{call_hash}/parent';
};

export type GetParentCallByHashErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetParentCallByHashError = GetParentCallByHashErrors[keyof GetParentCallByHashErrors];

export type GetParentCallByHashResponses = {
    /**
     * Parent call for the given sub call hash.
     */
    200: Call;
};

export type GetParentCallByHashResponse = GetParentCallByHashResponses[keyof GetParentCallByHashResponses];

export type GetSubCallsByHashData = {
    body?: never;
    path: {
        /**
         * Parent call hash in hex (with or without `0x` prefix, case-insensitive).
         */
        call_hash: string;
    };
    query?: {
        /**
         * Block call list page number to retrieve. 1-indexed.
         */
        page?: number;
        /**
         * Number of block calls per page to be returned.
         */
        page_size?: number;
        /**
         * Filter blocks calls by pallet name. Case insensitive.
         */
        pallet_name?: string;
        /**
         * Filter blocks calls by call name. Case insensitive.
         */
        pallet_call_name?: string;
        /**
         * Whether to include call arguments in the block calls in the response.
         * Default is `false`. Setting this to `true` increases the response size considerably.
         * Prefer to use the `GET /call/{call_hash}/args` endpoint per call instead.
         */
        include_args?: boolean;
    };
    url: '/calls/{call_hash}/subs';
};

export type GetSubCallsByHashErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetSubCallsByHashError = GetSubCallsByHashErrors[keyof GetSubCallsByHashErrors];

export type GetSubCallsByHashResponses = {
    /**
     * Paginated list of matching calls.
     */
    200: {
        data: Array<Call>;
        pagination: PaginationData;
    };
};

export type GetSubCallsByHashResponse = GetSubCallsByHashResponses[keyof GetSubCallsByHashResponses];

export type GetEventsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Events list page number to retrieve. 1-indexed.
         */
        page?: number;
        /**
         * Number of events per page to be returned.
         */
        page_size?: number;
        /**
         * Filter events by minimum block number.
         */
        min_block_number?: bigint;
        /**
         * Filter events by maximum block number.
         */
        max_block_number?: bigint;
        /**
         * Filter events by minimum block timestamp. In milliseconds.
         */
        min_block_timestamp?: bigint;
        /**
         * Filter events by maximum block timestamp. In milliseconds.
         */
        max_block_timestamp?: bigint;
        /**
         * Filter events by minimum runtime spec version.
         */
        min_spec_version?: number;
        /**
         * Filter events by maximum runtime spec version.
         */
        max_spec_version?: number;
        /**
         * Filter events by pallet name. Case insensitive. Stored in `camelCase`.
         */
        pallet_name?: string;
        /**
         * Filter events by event name. Case insensitive. Stored in `camelCase`.
         */
        event_name?: string;
        /**
         * Whether to include event arguments in the events in the response.
         * Default is `false`. Setting this to `true` increases response size considerably.
         * Prefer to use the `GET /event/{event_hash}/args` endpoint per event instead.
         */
        include_args?: boolean;
    };
    url: '/events';
};

export type GetEventsErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetEventsError = GetEventsErrors[keyof GetEventsErrors];

export type GetEventsResponses = {
    /**
     * Paginated list of matching events.
     */
    200: {
        data: Array<Event>;
        pagination: PaginationData;
    };
};

export type GetEventsResponse = GetEventsResponses[keyof GetEventsResponses];

export type GetEventByHashData = {
    body?: never;
    path: {
        /**
         * Event hash in hex (with or without `0x` prefix, case-insensitive).
         */
        event_hash: string;
    };
    query?: {
        /**
         * Whether to include event arguments in the event(s) in the response.
         * Default is `false`. Setting this to `true` increases the response size considerably.
         * Prefer to use the `GET /event/{event_hash}/args` endpoint per call instead.
         */
        include_args?: boolean;
    };
    url: '/events/{event_hash}';
};

export type GetEventByHashErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetEventByHashError = GetEventByHashErrors[keyof GetEventByHashErrors];

export type GetEventByHashResponses = {
    /**
     * Event with the given hash.
     */
    200: Event;
};

export type GetEventByHashResponse = GetEventByHashResponses[keyof GetEventByHashResponses];

export type GetEventArgsByHashData = {
    body?: never;
    path: {
        /**
         * Event hash in hex (with or without `0x` prefix, case-insensitive).
         */
        event_hash: string;
    };
    query?: never;
    url: '/events/{event_hash}/args';
};

export type GetEventArgsByHashErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetEventArgsByHashError = GetEventArgsByHashErrors[keyof GetEventArgsByHashErrors];

export type GetEventArgsByHashResponses = {
    /**
     * Arguments for the runtime event with the given hash.
     */
    200: EventArgs;
};

export type GetEventArgsByHashResponse = GetEventArgsByHashResponses[keyof GetEventArgsByHashResponses];

export type GetExtrinsicsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Extrinsic list page number to retrieve. 1-indexed.
         */
        page?: number;
        /**
         * Number of extrinsics per page to be returned.
         */
        page_size?: number;
        /**
         * Filter extrinsics by minimum block number.
         */
        min_block_number?: bigint;
        /**
         * Filter extrinsics by maximum block number.
         */
        max_block_number?: bigint;
        /**
         * Filter extrinsics by minimum block timestamp. In milliseconds.
         */
        min_block_timestamp?: bigint;
        /**
         * Filter extrinsics by maximum block timestamp. In milliseconds.
         */
        max_block_timestamp?: bigint;
        /**
         * Filter extrinsics by minimum runtime spec version.
         */
        min_spec_version?: number;
        /**
         * Filter extrinsics by maximum runtime spec version.
         */
        max_spec_version?: number;
        /**
         * Whether to include only signed/unsigned extrinsics.
         */
        is_signed?: boolean;
        /**
         * Filter extrinsics by signer. Either of the following:
         * - Signer's Substrate SS58 address string (e.g. `5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY`).
         * - Signer's Substrate account id encoded as a hexadecimal string (e.g. `0x008d8404893c7b4b80f397605cc96e61fec3c89676c8c2794a2a7d281d678b1a`).
         * - Signer's address encoded as a hexadecimal string with optional `0x` prefix (e.g. `0x008d8404893c7b4b80f397605cc96e61fec3c89676c8c2794a2a7d281d678b1a`).
         */
        signer?: string;
    };
    url: '/extrinsics';
};

export type GetExtrinsicsErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetExtrinsicsError = GetExtrinsicsErrors[keyof GetExtrinsicsErrors];

export type GetExtrinsicsResponses = {
    /**
     * Paginated list of matching extrinsics.
     */
    200: {
        data: Array<Extrinsic>;
        pagination: PaginationData;
    };
};

export type GetExtrinsicsResponse = GetExtrinsicsResponses[keyof GetExtrinsicsResponses];

export type GetExtrinsicByHashData = {
    body?: never;
    path: {
        /**
         * Extrinsic hash in hex (with or without `0x` prefix, case-insensitive).
         */
        extrinsic_hash: string;
    };
    query?: never;
    url: '/extrinsics/{extrinsic_hash}';
};

export type GetExtrinsicByHashErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetExtrinsicByHashError = GetExtrinsicByHashErrors[keyof GetExtrinsicByHashErrors];

export type GetExtrinsicByHashResponses = {
    /**
     * Extrinsic with the given hash.
     */
    200: Extrinsic;
};

export type GetExtrinsicByHashResponse = GetExtrinsicByHashResponses[keyof GetExtrinsicByHashResponses];

export type GetExtrinsicRootCallByHashData = {
    body?: never;
    path: {
        /**
         * Extrinsic hash in hex (with or without `0x` prefix, case-insensitive).
         */
        extrinsic_hash: string;
    };
    query?: {
        /**
         * Whether to include call arguments in the call(s) in the response.
         * Default is `false`. Setting this to `true` increases the response size considerably.
         * Prefer to use the `GET /call/{call_hash}/args` endpoint per call instead.
         */
        include_args?: boolean;
    };
    url: '/extrinsics/{extrinsic_hash}/call';
};

export type GetExtrinsicRootCallByHashErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetExtrinsicRootCallByHashError = GetExtrinsicRootCallByHashErrors[keyof GetExtrinsicRootCallByHashErrors];

export type GetExtrinsicRootCallByHashResponses = {
    /**
     * The root call of the extrinsic.
     */
    200: Call;
};

export type GetExtrinsicRootCallByHashResponse = GetExtrinsicRootCallByHashResponses[keyof GetExtrinsicRootCallByHashResponses];

export type GetCallsByExtrinsicHashData = {
    body?: never;
    path: {
        /**
         * Extrinsic hash in hex (with or without `0x` prefix, case-insensitive).
         */
        extrinsic_hash: string;
    };
    query?: {
        /**
         * Block call list page number to retrieve. 1-indexed.
         */
        page?: number;
        /**
         * Number of block calls per page to be returned.
         */
        page_size?: number;
        /**
         * Filter blocks calls by pallet name. Case insensitive.
         */
        pallet_name?: string;
        /**
         * Filter blocks calls by call name. Case insensitive.
         */
        pallet_call_name?: string;
        /**
         * Whether to include call arguments in the block calls in the response.
         * Default is `false`. Setting this to `true` increases the response size considerably.
         * Prefer to use the `GET /call/{call_hash}/args` endpoint per call instead.
         */
        include_args?: boolean;
    };
    url: '/extrinsics/{extrinsic_hash}/calls';
};

export type GetCallsByExtrinsicHashErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetCallsByExtrinsicHashError = GetCallsByExtrinsicHashErrors[keyof GetCallsByExtrinsicHashErrors];

export type GetCallsByExtrinsicHashResponses = {
    /**
     * Paginated list of matching calls.
     */
    200: {
        data: Array<Call>;
        pagination: PaginationData;
    };
};

export type GetCallsByExtrinsicHashResponse = GetCallsByExtrinsicHashResponses[keyof GetCallsByExtrinsicHashResponses];

export type GetEventsByExtrinsicHashData = {
    body?: never;
    path: {
        /**
         * Extrinsic hash in hex (with or without `0x` prefix, case-insensitive).
         */
        extrinsic_hash: string;
    };
    query?: {
        /**
         * Block event list page number to retrieve. 1-indexed.
         */
        page?: number;
        /**
         * Number of block events per page to be returned.
         */
        page_size?: number;
        /**
         * Filter events calls by pallet name. Case insensitive.
         */
        pallet_name?: string;
        /**
         * Filter blocks events by event name. Case insensitive.
         */
        pallet_event_name?: string;
        /**
         * Whether to include event arguments in the block events in the response.
         * Default is `false`. Setting this to `true` increases response size considerably.
         * Prefer to use the `GET /event/{event_hash}/args` endpoint per call instead.
         */
        include_args?: boolean;
    };
    url: '/extrinsics/{extrinsic_hash}/events';
};

export type GetEventsByExtrinsicHashErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetEventsByExtrinsicHashError = GetEventsByExtrinsicHashErrors[keyof GetEventsByExtrinsicHashErrors];

export type GetEventsByExtrinsicHashResponses = {
    /**
     * Paginated list of matching events.
     */
    200: {
        data: Array<Event>;
        pagination: PaginationData;
    };
};

export type GetEventsByExtrinsicHashResponse = GetEventsByExtrinsicHashResponses[keyof GetEventsByExtrinsicHashResponses];

export type GetGenesisRecordsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Genesis record list page number to retrieve. 1-indexed.
         */
        page?: number;
        /**
         * Number of genesis records per page to be returned.
         */
        page_size?: number;
    };
    url: '/genesis';
};

export type GetGenesisRecordsErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetGenesisRecordsError = GetGenesisRecordsErrors[keyof GetGenesisRecordsErrors];

export type GetGenesisRecordsResponses = {
    /**
     * Paginated list of genesis record items.
     */
    200: {
        data: Array<GenesisRecord>;
        pagination: PaginationData;
    };
};

export type GetGenesisRecordsResponse = GetGenesisRecordsResponses[keyof GetGenesisRecordsResponses];

export type GetMetadataListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page number to retrieve. 1-indexed.
         */
        page?: number;
        /**
         * Number of items per page to be returned.
         */
        page_size?: number;
    };
    url: '/metadata';
};

export type GetMetadataListErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetMetadataListError = GetMetadataListErrors[keyof GetMetadataListErrors];

export type GetMetadataListResponses = {
    /**
     * Response with a paginated list of metadata summaries.
     */
    200: {
        data: Array<MetadataSummary>;
        pagination: PaginationData;
    };
};

export type GetMetadataListResponse = GetMetadataListResponses[keyof GetMetadataListResponses];

export type GetMetadataData = {
    body?: never;
    path: {
        /**
         * Metadata spec version.
         */
        spec_version: number;
    };
    query?: never;
    url: '/metadata/{spec_version}';
};

export type GetMetadataErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetMetadataError = GetMetadataErrors[keyof GetMetadataErrors];

export type GetMetadataResponses = {
    /**
     * Full metadata with the given spec version.
     */
    200: Metadata;
};

export type GetMetadataResponse = GetMetadataResponses[keyof GetMetadataResponses];

export type GetMetadataHexData = {
    body?: never;
    path: {
        /**
         * Metadata spec version.
         */
        spec_version: number;
    };
    query?: never;
    url: '/metadata/{spec_version}/hex';
};

export type GetMetadataHexErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetMetadataHexError = GetMetadataHexErrors[keyof GetMetadataHexErrors];

export type GetMetadataHexResponses = {
    /**
     * SCALE-encoded prefixed metadata hexadecimal string.
     */
    200: HexString;
};

export type GetMetadataHexResponse = GetMetadataHexResponses[keyof GetMetadataHexResponses];

export type GetMetadataJsonData = {
    body?: never;
    path: {
        /**
         * Metadata spec version.
         */
        spec_version: number;
    };
    query?: never;
    url: '/metadata/{spec_version}/json';
};

export type GetMetadataJsonErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetMetadataJsonError = GetMetadataJsonErrors[keyof GetMetadataJsonErrors];

export type GetMetadataJsonResponses = {
    /**
     * Full metadata with the given spec version.
     */
    200: MetadataJson;
};

export type GetMetadataJsonResponse = GetMetadataJsonResponses[keyof GetMetadataJsonResponses];

export type GetMetadataPalletsData = {
    body?: never;
    path: {
        /**
         * Metadata spec version.
         */
        spec_version: number;
    };
    query?: never;
    url: '/metadata/{spec_version}/pallets';
};

export type GetMetadataPalletsErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetMetadataPalletsError = GetMetadataPalletsErrors[keyof GetMetadataPalletsErrors];

export type GetMetadataPalletsResponses = {
    /**
     * List of summaries of matching metadata pallets.
     */
    200: Array<MetadataPalletSummary>;
};

export type GetMetadataPalletsResponse = GetMetadataPalletsResponses[keyof GetMetadataPalletsResponses];

export type GetMetadataPalletData = {
    body?: never;
    path: {
        /**
         * Metadata spec version.
         */
        spec_version: number;
        /**
         * Metadata pallet index.
         */
        pallet_index: number;
    };
    query?: never;
    url: '/metadata/{spec_version}/pallets/{pallet_index}';
};

export type GetMetadataPalletErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetMetadataPalletError = GetMetadataPalletErrors[keyof GetMetadataPalletErrors];

export type GetMetadataPalletResponses = {
    /**
     * Full metadata pallet with the given spec version and pallet index.
     */
    200: MetadataPallet;
};

export type GetMetadataPalletResponse = GetMetadataPalletResponses[keyof GetMetadataPalletResponses];

export type GetMetadataPalletCallsData = {
    body?: never;
    path: {
        /**
         * Metadata spec version.
         */
        spec_version: number;
        /**
         * Metadata pallet index.
         */
        pallet_index: number;
    };
    query?: never;
    url: '/metadata/{spec_version}/pallets/{pallet_index}/calls';
};

export type GetMetadataPalletCallsErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetMetadataPalletCallsError = GetMetadataPalletCallsErrors[keyof GetMetadataPalletCallsErrors];

export type GetMetadataPalletCallsResponses = {
    /**
     * All calls in a pallet.
     */
    200: Array<MetadataCall>;
};

export type GetMetadataPalletCallsResponse = GetMetadataPalletCallsResponses[keyof GetMetadataPalletCallsResponses];

export type GetMetadataPalletConstantsData = {
    body?: never;
    path: {
        /**
         * Metadata spec version.
         */
        spec_version: number;
        /**
         * Metadata pallet index.
         */
        pallet_index: number;
    };
    query?: never;
    url: '/metadata/{spec_version}/pallets/{pallet_index}/constants';
};

export type GetMetadataPalletConstantsErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetMetadataPalletConstantsError = GetMetadataPalletConstantsErrors[keyof GetMetadataPalletConstantsErrors];

export type GetMetadataPalletConstantsResponses = {
    /**
     * All constants in a pallet.
     */
    200: Array<MetadataConstant>;
};

export type GetMetadataPalletConstantsResponse = GetMetadataPalletConstantsResponses[keyof GetMetadataPalletConstantsResponses];

export type GetMetadataPalletErrorsData = {
    body?: never;
    path: {
        /**
         * Metadata spec version.
         */
        spec_version: number;
        /**
         * Metadata pallet index.
         */
        pallet_index: number;
    };
    query?: never;
    url: '/metadata/{spec_version}/pallets/{pallet_index}/errors';
};

export type GetMetadataPalletErrorsErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetMetadataPalletErrorsError = GetMetadataPalletErrorsErrors[keyof GetMetadataPalletErrorsErrors];

export type GetMetadataPalletErrorsResponses = {
    /**
     * All errors in a pallet.
     */
    200: Array<MetadataError>;
};

export type GetMetadataPalletErrorsResponse = GetMetadataPalletErrorsResponses[keyof GetMetadataPalletErrorsResponses];

export type GetMetadataPalletEventsData = {
    body?: never;
    path: {
        /**
         * Metadata spec version.
         */
        spec_version: number;
        /**
         * Metadata pallet index.
         */
        pallet_index: number;
    };
    query?: never;
    url: '/metadata/{spec_version}/pallets/{pallet_index}/events';
};

export type GetMetadataPalletEventsErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetMetadataPalletEventsError = GetMetadataPalletEventsErrors[keyof GetMetadataPalletEventsErrors];

export type GetMetadataPalletEventsResponses = {
    /**
     * All events in a pallet.
     */
    200: Array<MetadataEvent>;
};

export type GetMetadataPalletEventsResponse = GetMetadataPalletEventsResponses[keyof GetMetadataPalletEventsResponses];

export type GetMetadataPalletStorageItemsData = {
    body?: never;
    path: {
        /**
         * Metadata spec version.
         */
        spec_version: number;
        /**
         * Metadata pallet index.
         */
        pallet_index: number;
    };
    query?: never;
    url: '/metadata/{spec_version}/pallets/{pallet_index}/storage';
};

export type GetMetadataPalletStorageItemsErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetMetadataPalletStorageItemsError = GetMetadataPalletStorageItemsErrors[keyof GetMetadataPalletStorageItemsErrors];

export type GetMetadataPalletStorageItemsResponses = {
    /**
     * All storage items in a pallet.
     */
    200: Array<MetadataStorageItem>;
};

export type GetMetadataPalletStorageItemsResponse = GetMetadataPalletStorageItemsResponses[keyof GetMetadataPalletStorageItemsResponses];

export type GetTracesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Trace list page number to retrieve. 1-indexed.
         */
        page?: number;
        /**
         * Number of traces per page to be returned.
         */
        page_size?: number;
        /**
         * Filter traces by minimum block number.
         */
        min_block_number?: bigint;
        /**
         * Filter traces by maximum block number.
         */
        max_block_number?: bigint;
        /**
         * Filter traces by minimum block timestamp. In milliseconds.
         */
        min_block_timestamp?: bigint;
        /**
         * Filter traces by maximum block timestamp. In milliseconds.
         */
        max_block_timestamp?: bigint;
        /**
         * Filter traces by minimum runtime spec version.
         */
        min_spec_version?: number;
        /**
         * Filter traces by maximum runtime spec version.
         */
        max_spec_version?: number;
        /**
         * Filter traces by Substrate storage key prefix.
         */
        key_prefix?: HexStringParam;
        /**
         * Filter traces by Substrate storage key parameters.
         */
        key_params?: HexStringParam;
    };
    url: '/traces';
};

export type GetTracesErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetTracesError = GetTracesErrors[keyof GetTracesErrors];

export type GetTracesResponses = {
    /**
     * Paginated list of matching traces.
     */
    200: {
        data: Array<Trace>;
        pagination: PaginationData;
    };
};

export type GetTracesResponse = GetTracesResponses[keyof GetTracesResponses];

export type GetTraceByHashData = {
    body?: never;
    path: {
        /**
         * Trace hash in hex (with or without `0x` prefix, case-insensitive).
         */
        trace_hash: string;
    };
    query?: never;
    url: '/traces/{trace_hash}';
};

export type GetTraceByHashErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetTraceByHashError = GetTraceByHashErrors[keyof GetTraceByHashErrors];

export type GetTraceByHashResponses = {
    /**
     * Trace with the given hash.
     */
    200: Trace;
};

export type GetTraceByHashResponse = GetTraceByHashResponses[keyof GetTraceByHashResponses];

export type GetTraceValueByHashData = {
    body?: never;
    path: {
        /**
         * Trace hash in hex (with or without `0x` prefix, case-insensitive).
         */
        trace_hash: string;
    };
    query?: never;
    url: '/traces/{trace_hash}/value';
};

export type GetTraceValueByHashErrors = {
    /**
     * Invalid path or query parameter(s).
     */
    400: Error;
    /**
     * Item not found.
     */
    404: Error;
    /**
     * Rate limit exceeded.
     */
    429: Error;
    /**
     * Internal server error.
     */
    500: Error;
};

export type GetTraceValueByHashError = GetTraceValueByHashErrors[keyof GetTraceValueByHashErrors];

export type GetTraceValueByHashResponses = {
    /**
     * SCALE-encoded value of the storage trace.
     */
    200: HexString;
    /**
     * Trace exists but has no value (null).
     */
    204: void;
};

export type GetTraceValueByHashResponse = GetTraceValueByHashResponses[keyof GetTraceValueByHashResponses];
