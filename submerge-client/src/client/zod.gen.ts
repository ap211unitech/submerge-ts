// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

/**
 * 32-byte Substrate account id as lowercase hex, **always** `0x`-prefixed and lowercase in responses.
 */
export const zAccountIdHex = z.string().regex(/^0x[a-f0-9]{64}$/);

/**
 * 20-byte address as lowercase hex, **always** `0x`-prefixed and lowercase in responses.
 */
export const zAddress20Hex = z.string().regex(/^0x[a-f0-9]{40}$/);

/**
 * 32-byte address as lowercase hex, **always** `0x`-prefixed and lowercase in responses.
 */
export const zAddress32Hex = z.string().regex(/^0x[a-f0-9]{64}$/);

/**
 * Block status.
 * - `finalized`: Blocks that have been finalized on chain.
 * - `proposed`: Blocks that have been authored but not yet finalized.
 * - `pruned`: Blocks that have been removed or are no longer accessible.
 */
export const zBlockStatus = z.enum([
    'proposed',
    'pruned',
    'finalized'
]);

/**
 * Call arguments wrapper.
 */
export const zCallArgs = z.record(z.string(), z.unknown());

/**
 * Generic error type.
 */
export const zError = z.object({
    message: z.string()
});

/**
 * Event arguments wrapper.
 */
export const zEventArgs = z.record(z.string(), z.unknown());

/**
 * 32-byte Blake2b-256, **always** `0x`-prefixed and lowercase in responses.
 * Inputs elsewhere may accept mixed case or missing `0x`; the API normalizes outputs.
 */
export const zHash256Hex = z.string().regex(/^0x[a-f0-9]{64}$/);

/**
 * A runtime call.
 */
export const zCall = z.object({
    args: z.optional(z.record(z.string(), z.unknown())),
    blockHash: zHash256Hex,
    blockNumber: z.coerce.bigint().gte(BigInt(0)),
    blockStatus: zBlockStatus,
    blockTimestamp: z.optional(z.coerce.bigint().gte(BigInt(0))),
    callIndex: z.array(z.int().gte(0)),
    callPath: z.string(),
    extrinsicHash: zHash256Hex,
    extrinsicIndex: z.int().gte(0),
    extrinsicIsSuccessful: z.boolean(),
    hash: zHash256Hex,
    palletCallIndex: z.int().gte(0),
    palletCallName: z.string(),
    palletIndex: z.int().gte(0),
    palletName: z.string(),
    parentCallHash: z.optional(zHash256Hex),
    specVersion: z.int().gte(0)
});

/**
 * A runtime event.
 */
export const zEvent = z.object({
    args: z.optional(z.record(z.string(), z.unknown())),
    blockHash: zHash256Hex,
    blockNumber: z.coerce.bigint().gte(BigInt(0)),
    blockStatus: zBlockStatus,
    blockTimestamp: z.optional(z.coerce.bigint().gte(BigInt(0))),
    extrinsicHash: z.optional(zHash256Hex),
    extrinsicIndex: z.optional(z.int().gte(0)),
    hash: zHash256Hex,
    index: z.int().gte(0),
    palletEventIndex: z.int().gte(0),
    palletEventName: z.string(),
    palletIndex: z.int().gte(0),
    palletName: z.string(),
    phase: z.string(),
    specVersion: z.int().gte(0),
    traceIndex: z.optional(z.int().gte(0))
});

/**
 * Arbitrary hex-encoded bytes, `0x`-prefixed.
 */
export const zHexString = z.string().regex(/^0x(?:[0-9a-f]{2})+$/);

/**
 * A storage item initialized at genesis.
 */
export const zGenesisRecord = z.object({
    keyParams: z.optional(zHexString),
    keyPrefix: zHexString,
    knownKey: z.optional(z.string()),
    palletIndex: z.optional(z.int().gte(0)),
    palletName: z.optional(z.string()),
    palletStorageItemIndex: z.optional(z.int().gte(0)),
    palletStorageItemName: z.optional(z.string()),
    value: zHexString
});

/**
 * Arbitrary hex-encoded bytes, mixed case, optional `0x`-prefix.
 */
export const zHexStringParam = z.string().regex(/^0x(?:[0-9a-f]{2})+$/);

/**
 * Metadata item documentation. One item per line in the array.
 */
export const zMetadataItemDocumentation = z.array(z.string());

/**
 * A call defined in a metadata pallet.
 */
export const zMetadataCall = z.object({
    docs: zMetadataItemDocumentation,
    index: z.int().gte(0),
    name: z.string()
});

/**
 * A constant defined in a metadata pallet.
 */
export const zMetadataConstant = z.object({
    docs: zMetadataItemDocumentation,
    index: z.int().gte(0),
    name: z.string(),
    typeId: z.optional(z.int().gte(0)),
    typeName: z.string(),
    value: z.optional(z.record(z.string(), z.unknown())),
    valueHex: zHexString
});

/**
 * An error defined in a metadata pallet.
 */
export const zMetadataError = z.object({
    docs: zMetadataItemDocumentation,
    index: z.int().gte(0),
    name: z.string()
});

/**
 * An event defined in a metadata pallet.
 */
export const zMetadataEvent = z.object({
    docs: zMetadataItemDocumentation,
    index: z.int().gte(0),
    name: z.string()
});

/**
 * Original Substrate runtime metadata in JSON representation.
 */
export const zMetadataJson = z.unknown();

/**
 * The summary of a pallet defined in metadata, with only its index and name.
 */
export const zMetadataPalletSummary = z.object({
    index: z.int().gte(0),
    name: z.string()
});

/**
 * A storage item defined in a metadata pallet.
 */
export const zMetadataStorageItem = z.object({
    docs: zMetadataItemDocumentation,
    index: z.int().gte(0),
    keyPrefix: zHexString,
    name: z.string()
});

/**
 * A pallet defined in metadata, with its calls, constants, errors, events, and storage items.
 */
export const zMetadataPallet = z.object({
    calls: z.array(zMetadataCall),
    constants: z.array(zMetadataConstant),
    errors: z.array(zMetadataError),
    events: z.array(zMetadataEvent),
    index: z.int().gte(0),
    name: z.string(),
    storageItems: z.array(zMetadataStorageItem)
});

/**
 * Parsed metadata specification complete with its pallets.
 */
export const zMetadata = z.object({
    metadataVersion: z.int().gte(0),
    pallets: z.array(zMetadataPallet),
    specVersion: z.int().gte(0)
});

/**
 * Basic fields to represent a runtime version metadata.
 */
export const zMetadataSummary = z.object({
    metadataVersion: z.int().gte(0),
    specVersion: z.int().gte(0)
});

/**
 * Multi-address 20-byte address type.
 */
export const zMultiAddress20Type = z.enum(['address20']);

/**
 * 20-byte address.
 */
export const zMultiAddress20 = z.object({
    type: zMultiAddress20Type,
    value: zAddress20Hex
});

/**
 * Multi-address 32-byte address type.
 */
export const zMultiAddress32Type = z.enum(['address32']);

/**
 * 32-byte address.
 */
export const zMultiAddress32 = z.object({
    type: zMultiAddress32Type,
    value: zAddress32Hex
});

/**
 * Multi-address 32-byte account id type.
 */
export const zMultiAddressAccountIdType = z.enum(['accountId']);

/**
 * 32-byte account id.
 */
export const zMultiAddressAccountId = z.object({
    type: zMultiAddressAccountIdType,
    value: zAccountIdHex
});

/**
 * Multi-address account index type.
 */
export const zMultiAddressIndexType = z.enum(['index']);

/**
 * Account index.
 */
export const zMultiAddressAccountIndex = z.object({
    type: zMultiAddressIndexType,
    value: z.int().gte(0)
});

/**
 * Multi-address raw account address type.
 */
export const zMultiAddressRawType = z.enum(['raw']);

/**
 * Raw account address.
 */
export const zMultiAddressRaw = z.object({
    type: zMultiAddressRawType,
    value: zHexString
});

/**
 * Discriminated union for the Substrate multi-address type.
 * The `type` tag selects the variant; `value` carries the payload.
 */
export const zMultiAddress = z.union([
    z.object({
        type: z.literal('accountId')
    }).and(zMultiAddressAccountId),
    z.object({
        type: z.literal('MultiAddressAccountIndex')
    }).and(zMultiAddressAccountIndex),
    z.object({
        type: z.literal('raw')
    }).and(zMultiAddressRaw),
    z.object({
        type: z.literal('address20')
    }).and(zMultiAddress20),
    z.object({
        type: z.literal('address32')
    }).and(zMultiAddress32)
]);

/**
 * A block in the blockchain.
 */
export const zBlock = z.object({
    author: z.optional(zMultiAddress),
    eventCount: z.int().gte(0),
    extrinsicCount: z.int().gte(0),
    extrinsicRoot: zHash256Hex,
    hash: zHash256Hex,
    number: z.coerce.bigint().gte(BigInt(0)),
    parentHash: zHash256Hex,
    specVersion: z.int().gte(0),
    stateRoot: zHash256Hex,
    status: zBlockStatus,
    timestamp: z.optional(z.coerce.bigint().gte(BigInt(0))),
    weight: z.optional(z.record(z.string(), z.unknown()))
});

/**
 * Multi-signature ECDSA type.
 */
export const zMultiSignatureEcdsaType = z.enum(['ecdsa']);

/**
 * Multi-signature Ed25519 type.
 */
export const zMultiSignatureEd25519Type = z.enum(['ed25519']);

/**
 * Multi-signature Eth type (ECDSA over secp256k1, applied to a Keccak-256 hash).
 */
export const zMultiSignatureEthType = z.enum(['eth']);

/**
 * Multi-signature Sr25519 type.
 */
export const zMultiSignatureSr25519Type = z.enum(['sr25519']);

/**
 * Pagination data for paged responses.
 */
export const zPaginationData = z.object({
    page: z.int().gte(1),
    pageSize: z.int().gte(1),
    total: z.coerce.bigint().gte(BigInt(0))
});

/**
 * and ECDSA (65 bytes â†’ 130 hex chars). **Always** `0x`-prefixed and lowercase in responses.
 * Inputs elsewhere may accept mixed case or missing `0x`; the API normalizes outputs.
 */
export const zSignatureHexString = z.string().regex(/^0x([0-9a-f]{128}|[0-9a-f]{130})$/);

/**
 * ECDSA signature.
 */
export const zMultiSignatureEcdsa = z.object({
    type: zMultiSignatureEcdsaType,
    value: zSignatureHexString
});

/**
 * Ed25519 signature.
 */
export const zMultiSignatureEd25519 = z.object({
    type: zMultiSignatureEd25519Type,
    value: zSignatureHexString
});

/**
 * Eth signature.
 */
export const zMultiSignatureEth = z.object({
    type: zMultiSignatureEthType,
    value: zSignatureHexString
});

/**
 * Sr25519 signature.
 */
export const zMultiSignatureSr25519 = z.object({
    type: zMultiSignatureSr25519Type,
    value: zSignatureHexString
});

/**
 * Discriminated union for the Substrate multi-signature type.
 * The `type` tag selects the variant; `value` carries the payload.
 */
export const zMultiSignature = z.union([
    z.object({
        type: z.literal('ecdsa')
    }).and(zMultiSignatureEcdsa),
    z.object({
        type: z.literal('eth')
    }).and(zMultiSignatureEth),
    z.object({
        type: z.literal('ed25519')
    }).and(zMultiSignatureEd25519),
    z.object({
        type: z.literal('sr25519')
    }).and(zMultiSignatureSr25519)
]);

/**
 * An extrinsic in a block. Signed or unsigned.
 */
export const zExtrinsic = z.object({
    blockHash: zHash256Hex,
    blockNumber: z.coerce.bigint().gte(BigInt(0)),
    blockStatus: zBlockStatus,
    blockTimestamp: z.optional(z.coerce.bigint().gte(BigInt(0))),
    extra: z.optional(z.record(z.string(), z.unknown())),
    hash: zHash256Hex,
    index: z.int().gte(0),
    isSuccessful: z.boolean(),
    signature: z.optional(zMultiSignature),
    signer: z.optional(zMultiAddress),
    specVersion: z.int().gte(0),
    traceIndex: z.optional(z.int().gte(0)),
    version: z.int().gte(0)
});

/**
 * Block trace storage method.
 */
export const zTraceStorageMethod = z.enum([
    'Put',
    'ChildPut',
    'ChildKill',
    'ClearPrefix',
    'ChildClearPrefix',
    'Append',
    'Genesis'
]);

/**
 * A trace record in a block.
 */
export const zTrace = z.object({
    blockHash: zHash256Hex,
    blockNumber: z.coerce.bigint().gte(BigInt(0)),
    extId: zHexString,
    hash: zHash256Hex,
    index: z.int().gte(0),
    keyParams: z.optional(zHexString),
    keyPrefix: zHexString,
    knownKey: z.optional(z.string()),
    palletIndex: z.optional(z.int().gte(0)),
    palletName: z.optional(z.string()),
    palletStorageItemIndex: z.optional(z.int().gte(0)),
    palletStorageItemName: z.optional(z.string()),
    parentId: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    specVersion: z.int().gte(0),
    storageMethod: zTraceStorageMethod
});

export const zGetBlocksData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(1).lte(100)).default(25),
        status: z.optional(zBlockStatus),
        min_block_number: z.optional(z.coerce.bigint().gte(BigInt(0))),
        max_block_number: z.optional(z.coerce.bigint().gte(BigInt(0))),
        min_block_timestamp: z.optional(z.coerce.bigint().gte(BigInt(0))),
        max_block_timestamp: z.optional(z.coerce.bigint().gte(BigInt(0))),
        min_spec_version: z.optional(z.int().gte(0)),
        max_spec_version: z.optional(z.int().gte(0)),
        author: z.optional(z.string().regex(/^(?:[1-9A-HJ-NP-Za-km-z]{47,48}|(?:0x)?[0-9a-fA-F]{1-256})$/))
    }))
});

/**
 * Paginated list of matching blocks.
 */
export const zGetBlocksResponse = z.object({
    data: z.array(zBlock),
    pagination: zPaginationData
});

export const zGetBlocksByReferenceData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        block_ref: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/)
    }),
    query: z.optional(z.never())
});

/**
 * List of matching blocks.
 */
export const zGetBlocksByReferenceResponse = z.array(zBlock);

export const zGetCallsByBlockReferenceData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        block_ref: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/)
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(1).lte(100)).default(25),
        pallet_name: z.optional(z.string()),
        pallet_call_name: z.optional(z.string()),
        include_args: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Paginated list of matching calls.
 */
export const zGetCallsByBlockReferenceResponse = z.object({
    data: z.array(zCall),
    pagination: zPaginationData
});

export const zGetEventsByBlockReferenceData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        block_ref: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/)
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(1).lte(100)).default(25),
        pallet_name: z.optional(z.string()),
        pallet_event_name: z.optional(z.string()),
        include_args: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Paginated list of matching events.
 */
export const zGetEventsByBlockReferenceResponse = z.object({
    data: z.array(zEvent),
    pagination: zPaginationData
});

export const zGetEventsByBlockReferenceAndIndexData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        block_ref: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/),
        event_index: z.int().gte(0)
    }),
    query: z.optional(z.object({
        include_args: z.optional(z.boolean()).default(false)
    }))
});

/**
 * List of matching events.
 */
export const zGetEventsByBlockReferenceAndIndexResponse = z.array(zEvent);

export const zGetExtrinsicsByBlockReferenceData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        block_ref: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/)
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(1).lte(100)).default(25),
        is_signed: z.optional(z.boolean()),
        signer: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    }))
});

/**
 * Paginated list of matching extrinsics.
 */
export const zGetExtrinsicsByBlockReferenceResponse = z.object({
    data: z.array(zExtrinsic),
    pagination: zPaginationData
});

export const zGetExtrinsicsByBlockReferenceAndIndexData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        block_ref: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/),
        extrinsic_index: z.int().gte(0)
    }),
    query: z.optional(z.never())
});

/**
 * List of matching extrinsics.
 */
export const zGetExtrinsicsByBlockReferenceAndIndexResponse = z.array(zExtrinsic);

export const zGetCallsByBlockReferenceAndExtrinsicIndexData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        block_ref: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/),
        extrinsic_index: z.int().gte(0)
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(1).lte(100)).default(25),
        pallet_name: z.optional(z.string()),
        pallet_call_name: z.optional(z.string()),
        include_args: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Paginated list of matching calls.
 */
export const zGetCallsByBlockReferenceAndExtrinsicIndexResponse = z.object({
    data: z.array(zCall),
    pagination: zPaginationData
});

export const zGetEventsByBlockReferenceAndExtrinsicIndexData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        block_ref: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/),
        extrinsic_index: z.int().gte(0)
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(1).lte(100)).default(25),
        pallet_name: z.optional(z.string()),
        pallet_event_name: z.optional(z.string()),
        include_args: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Paginated list of matching events.
 */
export const zGetEventsByBlockReferenceAndExtrinsicIndexResponse = z.object({
    data: z.array(zEvent),
    pagination: zPaginationData
});

export const zGetTracesByBlockReferenceData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        block_ref: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/)
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(1).lte(100)).default(25)
    }))
});

/**
 * Paginated list of matching traces.
 */
export const zGetTracesByBlockReferenceResponse = z.object({
    data: z.array(zTrace),
    pagination: zPaginationData
});

export const zGetCallsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(1).lte(100)).default(25),
        min_block_number: z.optional(z.coerce.bigint().gte(BigInt(0))),
        max_block_number: z.optional(z.coerce.bigint().gte(BigInt(0))),
        min_block_timestamp: z.optional(z.coerce.bigint().gte(BigInt(0))),
        max_block_timestamp: z.optional(z.coerce.bigint().gte(BigInt(0))),
        min_spec_version: z.optional(z.int().gte(0)),
        max_spec_version: z.optional(z.int().gte(0)),
        pallet_name: z.optional(z.string()),
        call_name: z.optional(z.string()),
        include_args: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Paginated list of matching calls.
 */
export const zGetCallsResponse = z.object({
    data: z.array(zCall),
    pagination: zPaginationData
});

export const zGetCallByHashData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        call_hash: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/)
    }),
    query: z.optional(z.object({
        include_args: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Call with the given hash.
 */
export const zGetCallByHashResponse = zCall;

export const zGetCallArgsByHashData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        call_hash: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/)
    }),
    query: z.optional(z.never())
});

/**
 * Arguments for the runtime call with the given hash.
 */
export const zGetCallArgsByHashResponse = zCallArgs;

export const zGetCallExtrinsicByHashData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        call_hash: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/)
    }),
    query: z.optional(z.never())
});

/**
 * The extrinsic that contains the call.
 */
export const zGetCallExtrinsicByHashResponse = zExtrinsic;

export const zGetParentCallByHashData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        call_hash: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/)
    }),
    query: z.optional(z.object({
        include_args: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Parent call for the given sub call hash.
 */
export const zGetParentCallByHashResponse = zCall;

export const zGetSubCallsByHashData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        call_hash: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/)
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(1).lte(100)).default(25),
        pallet_name: z.optional(z.string()),
        pallet_call_name: z.optional(z.string()),
        include_args: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Paginated list of matching calls.
 */
export const zGetSubCallsByHashResponse = z.object({
    data: z.array(zCall),
    pagination: zPaginationData
});

export const zGetEventsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(1).lte(100)).default(25),
        min_block_number: z.optional(z.coerce.bigint().gte(BigInt(0))),
        max_block_number: z.optional(z.coerce.bigint().gte(BigInt(0))),
        min_block_timestamp: z.optional(z.coerce.bigint().gte(BigInt(0))),
        max_block_timestamp: z.optional(z.coerce.bigint().gte(BigInt(0))),
        min_spec_version: z.optional(z.int().gte(0)),
        max_spec_version: z.optional(z.int().gte(0)),
        pallet_name: z.optional(z.string()),
        event_name: z.optional(z.string()),
        include_args: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Paginated list of matching events.
 */
export const zGetEventsResponse = z.object({
    data: z.array(zEvent),
    pagination: zPaginationData
});

export const zGetEventByHashData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        event_hash: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/)
    }),
    query: z.optional(z.object({
        include_args: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Event with the given hash.
 */
export const zGetEventByHashResponse = zEvent;

export const zGetEventArgsByHashData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        event_hash: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/)
    }),
    query: z.optional(z.never())
});

/**
 * Arguments for the runtime event with the given hash.
 */
export const zGetEventArgsByHashResponse = zEventArgs;

export const zGetExtrinsicsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(1).lte(100)).default(25),
        min_block_number: z.optional(z.coerce.bigint().gte(BigInt(0))),
        max_block_number: z.optional(z.coerce.bigint().gte(BigInt(0))),
        min_block_timestamp: z.optional(z.coerce.bigint().gte(BigInt(0))),
        max_block_timestamp: z.optional(z.coerce.bigint().gte(BigInt(0))),
        min_spec_version: z.optional(z.int().gte(0)),
        max_spec_version: z.optional(z.int().gte(0)),
        is_signed: z.optional(z.boolean()),
        signer: z.optional(z.string().regex(/^(?:[1-9A-HJ-NP-Za-km-z]{47,48}|(?:0x)?[0-9a-fA-F]{1-256})$/))
    }))
});

/**
 * Paginated list of matching extrinsics.
 */
export const zGetExtrinsicsResponse = z.object({
    data: z.array(zExtrinsic),
    pagination: zPaginationData
});

export const zGetExtrinsicByHashData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        extrinsic_hash: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/)
    }),
    query: z.optional(z.never())
});

/**
 * Extrinsic with the given hash.
 */
export const zGetExtrinsicByHashResponse = zExtrinsic;

export const zGetExtrinsicRootCallByHashData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        extrinsic_hash: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/)
    }),
    query: z.optional(z.object({
        include_args: z.optional(z.boolean()).default(false)
    }))
});

/**
 * The root call of the extrinsic.
 */
export const zGetExtrinsicRootCallByHashResponse = zCall;

export const zGetCallsByExtrinsicHashData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        extrinsic_hash: z.string().regex(/^(?:0x)?[0-9a-fA-F]{64}$/)
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(1).lte(100)).default(25),
        pallet_name: z.optional(z.string()),
        pallet_call_name: z.optional(z.string()),
        include_args: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Paginated list of matching calls.
 */
export const zGetCallsByExtrinsicHashResponse = z.object({
    data: z.array(zCall),
    pagination: zPaginationData
});

export const zGetEventsByExtrinsicHashData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        extrinsic_hash: z.string().regex(/^(?:0x)?[0-9a-fA-F]{64}$/)
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(1).lte(100)).default(25),
        pallet_name: z.optional(z.string()),
        pallet_event_name: z.optional(z.string()),
        include_args: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Paginated list of matching events.
 */
export const zGetEventsByExtrinsicHashResponse = z.object({
    data: z.array(zEvent),
    pagination: zPaginationData
});

export const zGetGenesisRecordsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(1).lte(100)).default(25)
    }))
});

/**
 * Paginated list of genesis record items.
 */
export const zGetGenesisRecordsResponse = z.object({
    data: z.array(zGenesisRecord),
    pagination: zPaginationData
});

export const zGetMetadataListData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(0)),
        page_size: z.optional(z.int().gte(0))
    }))
});

/**
 * Response with a paginated list of metadata summaries.
 */
export const zGetMetadataListResponse = z.object({
    data: z.array(zMetadataSummary),
    pagination: zPaginationData
});

export const zGetMetadataData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        spec_version: z.int().gte(0)
    }),
    query: z.optional(z.never())
});

/**
 * Full metadata with the given spec version.
 */
export const zGetMetadataResponse = zMetadata;

export const zGetMetadataHexData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        spec_version: z.int().gte(0)
    }),
    query: z.optional(z.never())
});

/**
 * SCALE-encoded prefixed metadata hexadecimal string.
 */
export const zGetMetadataHexResponse = zHexString;

export const zGetMetadataJsonData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        spec_version: z.int().gte(0)
    }),
    query: z.optional(z.never())
});

/**
 * Full metadata with the given spec version.
 */
export const zGetMetadataJsonResponse = zMetadataJson;

export const zGetMetadataPalletsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        spec_version: z.int().gte(0)
    }),
    query: z.optional(z.never())
});

/**
 * List of summaries of matching metadata pallets.
 */
export const zGetMetadataPalletsResponse = z.array(zMetadataPalletSummary);

export const zGetMetadataPalletData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        spec_version: z.int().gte(0),
        pallet_index: z.int().gte(0)
    }),
    query: z.optional(z.never())
});

/**
 * Full metadata pallet with the given spec version and pallet index.
 */
export const zGetMetadataPalletResponse = zMetadataPallet;

export const zGetMetadataPalletCallsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        spec_version: z.int().gte(0),
        pallet_index: z.int().gte(0)
    }),
    query: z.optional(z.never())
});

/**
 * All calls in a pallet.
 */
export const zGetMetadataPalletCallsResponse = z.array(zMetadataCall);

export const zGetMetadataPalletConstantsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        spec_version: z.int().gte(0),
        pallet_index: z.int().gte(0)
    }),
    query: z.optional(z.never())
});

/**
 * All constants in a pallet.
 */
export const zGetMetadataPalletConstantsResponse = z.array(zMetadataConstant);

export const zGetMetadataPalletErrorsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        spec_version: z.int().gte(0),
        pallet_index: z.int().gte(0)
    }),
    query: z.optional(z.never())
});

/**
 * All errors in a pallet.
 */
export const zGetMetadataPalletErrorsResponse = z.array(zMetadataError);

export const zGetMetadataPalletEventsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        spec_version: z.int().gte(0),
        pallet_index: z.int().gte(0)
    }),
    query: z.optional(z.never())
});

/**
 * All events in a pallet.
 */
export const zGetMetadataPalletEventsResponse = z.array(zMetadataEvent);

export const zGetMetadataPalletStorageItemsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        spec_version: z.int().gte(0),
        pallet_index: z.int().gte(0)
    }),
    query: z.optional(z.never())
});

/**
 * All storage items in a pallet.
 */
export const zGetMetadataPalletStorageItemsResponse = z.array(zMetadataStorageItem);

export const zGetTracesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(1).lte(100)).default(25),
        min_block_number: z.optional(z.coerce.bigint().gte(BigInt(0))),
        max_block_number: z.optional(z.coerce.bigint().gte(BigInt(0))),
        min_block_timestamp: z.optional(z.coerce.bigint().gte(BigInt(0))),
        max_block_timestamp: z.optional(z.coerce.bigint().gte(BigInt(0))),
        min_spec_version: z.optional(z.int().gte(0)),
        max_spec_version: z.optional(z.int().gte(0)),
        key_prefix: z.optional(zHexStringParam),
        key_params: z.optional(zHexStringParam)
    }))
});

/**
 * Paginated list of matching traces.
 */
export const zGetTracesResponse = z.object({
    data: z.array(zTrace),
    pagination: zPaginationData
});

export const zGetTraceByHashData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        trace_hash: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/)
    }),
    query: z.optional(z.never())
});

/**
 * Trace with the given hash.
 */
export const zGetTraceByHashResponse = zTrace;

export const zGetTraceValueByHashData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        trace_hash: z.string().regex(/^(?:\d+|(0x)?[a-f0-9A-F]{64})$/)
    }),
    query: z.optional(z.never())
});

export const zGetTraceValueByHashResponse = z.union([
    zHexString,
    z.void()
]);
